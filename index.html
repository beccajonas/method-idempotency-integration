<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Method Idempotency Demo</title>
    <style>
        body {
            font-family: sans-serif;
            max-width: 600px;
            margin: 2rem auto;
            padding: 1rem;
        }

        input, button {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            box-sizing: border-box;
        }

        button {
            cursor: pointer;
        }

        pre {
            background: #f7f7f7;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
        }

        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        @media (max-width: 768px) {
            .results {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Method Idempotency Demo</h1>
    
    <form id="paymentForm">
        <label for="amount">Amount (cents)</label>
        <input type="number" id="amount" required>

        <label for="source">Source Account ID</label>
        <input type="text" id="source" required>

        <label for="destination">Destination Account ID</label>
        <input type="text" id="destination" required>

        <label for="description">Description</label>
        <input type="text" id="description" required>

        <label for="apiKey">API Key</label>
        <input type="password" id="apiKey" placeholder="sk_..." required>

        <label for="idempotencyKey">Idempotency Key</label>
        <input type="text" id="idempotencyKey" placeholder="Leave empty to auto-generate">
        <small style="color: #666; display: block; margin-top: -0.5rem; margin-bottom: 1rem;">This key will persist and be reused for all requests. Same key = same result!</small>

        <button type="button" id="sendOnceBtn">Send Request Once</button>
        <button type="button" id="sendTwiceBtn">Send Same Request Twice</button>
        <button type="button" id="clearBtn">Clear Results</button>
    </form>

    <div class="results" id="results" style="display: none;">
        <div>
            <h3>First Request <span id="status1"></span></h3>
            <pre id="response1">Waiting for request...</pre>
            <div id="timestamp1"></div>
        </div>

        <div>
            <h3>Second Request <span id="status2"></span></h3>
            <pre id="response2">Waiting for request...</pre>
            <div id="timestamp2"></div>
        </div>
    </div>

    <script>
        document.getElementById('idempotencyKey').value = crypto.randomUUID();

        function updateStatus(index, status) {
            const statusEl = document.getElementById(`status${index}`);
            statusEl.textContent = status ? `(${status})` : '';
        }

        function updateResponse(index, data, timestamp) {
            document.getElementById(`response${index}`).textContent = JSON.stringify(data, null, 2);
            document.getElementById(`timestamp${index}`).textContent = timestamp ? `Sent at: ${timestamp}` : '';
        }

        async function sendPayment(idempotencyKey, index) {
            const amount = document.getElementById('amount').value;
            const source = document.getElementById('source').value;
            const destination = document.getElementById('destination').value;
            const description = document.getElementById('description').value;
            const apiKey = document.getElementById('apiKey').value;

            updateStatus(index, 'Sending...');

            const timestamp = new Date().toLocaleTimeString();

            try {
                const response = await fetch('/api/payment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        amount: parseInt(amount),
                        source,
                        destination,
                        description,
                        idempotencyKey,
                        apiKey
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    updateStatus(index, `Success ${response.status}`);
                } else {
                    updateStatus(index, `Error ${response.status}`);
                }

                updateResponse(index, {
                    status: response.status,
                    statusText: response.statusText,
                    headers: Object.fromEntries(response.headers.entries()),
                    body: data
                }, timestamp);

            } catch (error) {
                updateStatus(index, 'Network Error');
                updateResponse(index, {
                    error: error.message
                }, timestamp);
            }
        }

        document.getElementById('sendOnceBtn').addEventListener('click', async () => {
            const btn = document.getElementById('sendOnceBtn');
            btn.disabled = true;
            
            document.getElementById('results').style.display = 'grid';

            let key = document.getElementById('idempotencyKey').value;
            if (!key) {
                key = crypto.randomUUID();
                document.getElementById('idempotencyKey').value = key;
            }
            
            updateStatus(2, '');
            document.getElementById('response2').textContent = 'This request was not sent.';
            document.getElementById('timestamp2').textContent = '';

            await sendPayment(key, 1);
        });

        document.getElementById('sendTwiceBtn').addEventListener('click', async () => {
            const btn = document.getElementById('sendOnceBtn');
            const btn2 = document.getElementById('sendTwiceBtn');
            const firstRequestAlreadySent = btn.disabled;
            
            btn.disabled = true;
            btn2.disabled = true;
            
            document.getElementById('results').style.display = 'grid';
        
            let key = document.getElementById('idempotencyKey').value;
            if (!key) {
                key = crypto.randomUUID();
                document.getElementById('idempotencyKey').value = key;
            }
            
            if (!firstRequestAlreadySent) {
                await sendPayment(key, 1);
            }
            
            setTimeout(async () => {
                await sendPayment(key, 2);
            }, 500);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            document.getElementById('results').style.display = 'none';
            updateStatus(1, '');
            updateStatus(2, '');
            document.getElementById('response1').textContent = 'Waiting for request...';
            document.getElementById('response2').textContent = 'Waiting for request...';
            document.getElementById('timestamp1').textContent = '';
            document.getElementById('timestamp2').textContent = '';
            document.getElementById('sendOnceBtn').disabled = false;
            document.getElementById('sendTwiceBtn').disabled = false;
        });
    </script>
</body>
</html>

